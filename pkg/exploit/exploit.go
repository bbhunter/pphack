/*
pphack - The Most Advanced Client-Side Prototype Pollution Scanner

This repository is under MIT License https://github.com/edoardottt/pphack/blob/main/LICENSE
*/

package exploit

import (
	"context"
	_ "embed"
	"encoding/json"
	"errors"
	"log"
	"strings"
	"sync"
	"time"

	"github.com/chromedp/cdproto/page"
	"github.com/chromedp/chromedp"
	"github.com/projectdiscovery/gologger"
)

var (
	//go:embed exploits.json
	exploitsJSON string

	//go:embed fingerprint.js
	Fingerprint string

	exploits           map[string]Product
	ErrProductNotFound = errors.New("product not found")
)

type Product struct {
	Reference string `json:"reference"`
	Exploits  []struct {
		Payload    string `json:"payload"`
		Verifiable string `json:"verifiable"`
	} `json:"exploits"`
}

func init() {
	if err := json.Unmarshal([]byte(exploitsJSON), &exploits); err != nil {
		log.Fatal("error while unmarshaling exploits.json")
	}
}

func CheckExploit(pctx context.Context, chromedpTasks chromedp.Tasks, fingerprint []string,
	targetURL string, verbose bool, timeout int) ([]string, error) {
	var (
		result []string
		wg     sync.WaitGroup
	)

	target := strings.Split(targetURL, "?")

	for _, product := range fingerprint {
		wg.Add(1)

		info, err := GetProductInfo(product)
		if err != nil && verbose {
			gologger.Error().Msg(err.Error())
		}

		go func() {
			for _, exploit := range info.Exploits {
				ctx, cancel := context.WithTimeout(pctx, time.Second*time.Duration(timeout))
				ctx, _ = chromedp.NewContext(ctx)

				chromedp.ListenTarget(ctx, func(ev interface{}) {
					if ev, ok := ev.(*page.EventJavascriptDialogOpening); ok {
						result = append(result, ev.URL)

						cancel()
					}
				})

				chromedpTasksa := append(chromedpTasks, chromedp.Navigate(target[0]+exploit.Payload))

				err = chromedp.Run(ctx, chromedpTasksa)

				if err != nil && verbose {
					gologger.Error().Msg(err.Error())
				}

				cancel()
			}

			wg.Done()
		}()
	}

	wg.Wait()

	return result, nil
}
